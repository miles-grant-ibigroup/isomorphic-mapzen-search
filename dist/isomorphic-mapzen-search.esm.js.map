{"version":3,"file":"isomorphic-mapzen-search.esm.js","sources":["../index.ts"],"sourcesContent":["import { stringify } from 'qs'\nimport type { LonLatInput, LonLatOutput } from '@conveyal/lonlat'\nimport { normalize, fromCoordinates } from '@conveyal/lonlat'\n\nif (typeof fetch === 'undefined') {\n  require('isomorphic-fetch')\n}\n\nconst mapzenUrl = 'https://search.mapzen.com/v1'\nconst autocompleteUrl = `${mapzenUrl}/autocomplete`\nconst reverseUrl = `${mapzenUrl}/reverse`\nconst searchUrl = `${mapzenUrl}/search`\n\ntype Rect = {\n  maxLat: number\n  maxLon: number\n  minLat: number\n  minLon: number\n}\ntype Boundary = {\n  country: string\n  rect: Rect\n}\n\ntype Query = {\n  // apiKey is renamed depending on if it is being passed around or into fetch\n  // OK to disable this rule as api_key is a hack to conform with api\n  // eslint-disable-next-line camelcase\n  api_key: string\n  apiKey?: string\n  boundary?: Boundary\n  focusPoint?: LonLatInput\n  format?: boolean\n  layers?: string\n  options?: RequestInit // Built-in Typing\n  point?: GeoJSON.Point | LonLatOutput\n  size?: number\n  sources?: string\n  text?: string\n  url?: string\n}\n\ntype PeliasFetchArgs = {\n  format: boolean\n  options: RequestInit // Built-in Typing\n  query: Query\n  url: string\n}\n\ntype JSONArrayPromise = Promise<Array<JSON>>\n\n/**\n * Search for and address using\n * Mapzen's {@link https://mapzen.com/documentation/search/autocomplete/|Autocomplete}\n * service.\n *\n * @param {Object} $0\n * @param  {string} $0.apiKey                     The Mapzen API key\n * @param  {Object} $0.boundary\n * @param  {Object} $0.focusPoint\n * @param  {boolean} $0.format\n * @param  {string} $0.layers                     a comma-separated list of\n *   {@link https://mapzen.com/documentation/search/autocomplete/#layers|layer types}\n * @param  {Object} $0.options                    options to pass to fetch (e.g., custom headers)\n * @param  {string} [$0.sources='gn,oa,osm,wof']\n * @param  {string} $0.text                       query text\n * @param {string} [$0.url='https://search.mapzen.com/v1/autocomplete']                       optional URL to override Mapzen autocomplete endpoint\n * @return {Promise}                              A Promise that'll get resolved with the autocomplete result\n */\nexport function autocomplete({\n  apiKey,\n  boundary,\n  focusPoint,\n  format,\n  layers,\n  options,\n  sources = 'gn,oa,osm,wof',\n  text,\n  url = autocompleteUrl\n}: Query): JSONArrayPromise {\n  // build query\n  const query: Query = { api_key: apiKey, text }\n\n  if (sources && sources.length > 0) query.sources = sources\n\n  if (layers) {\n    query.layers = layers\n  }\n\n  if (focusPoint) {\n    const { lat, lon }: LonLatOutput = normalize(focusPoint)\n    query['focus.point.lat'] = lat\n    query['focus.point.lon'] = lon\n  }\n\n  if (boundary) {\n    if (boundary.country) query['boundary.country'] = boundary.country\n    if (boundary.rect) {\n      query['boundary.rect.min_lat'] = boundary.rect.minLat\n      query['boundary.rect.min_lon'] = boundary.rect.minLon\n      query['boundary.rect.max_lat'] = boundary.rect.maxLat\n      query['boundary.rect.max_lon'] = boundary.rect.maxLon\n    }\n  }\n\n  return run({\n    format,\n    options,\n    query,\n    url\n  })\n}\n\n/**\n * Search for an address using\n * Mapzen's {@link https://mapzen.com/documentation/search/search/|Search}\n * service.\n *\n * @param {Object} $0\n * @param {string} $0.apiKey                    The Mapzen API key\n * @param {Object} $0.boundary\n * @param {Object} $0.focusPoint\n * @param {boolean} $0.format\n * @param  {Object} $0.options                  options to pass to fetch (e.g., custom headers)\n * @param {number} [$0.size=10]\n * @param {string} [$0.sources='gn,oa,osm,wof']\n * @param {string} $0.text                      The address text to query for\n * @param {string} [$0.url='https://search.mapzen.com/v1/search']                     optional URL to override Mapzen search endpoint\n * @return {Promise}                            A Promise that'll get resolved with search result\n */\nexport function search({\n  apiKey,\n  boundary,\n  focusPoint,\n  format,\n  options,\n  size = 10,\n  sources = 'gn,oa,osm,wof',\n  text,\n  url = searchUrl\n}: Query): JSONArrayPromise {\n  if (!text) return Promise.resolve([])\n\n  const query: Query = {\n    api_key: apiKey,\n    size,\n    text\n  }\n\n  if (sources && sources.length > 0) query.sources = sources\n\n  if (focusPoint) {\n    const { lat, lon }: LonLatOutput = normalize(focusPoint)\n    query['focus.point.lat'] = lat\n    query['focus.point.lon'] = lon\n  }\n\n  if (boundary) {\n    if (boundary.country) query['boundary.country'] = boundary.country\n    if (boundary.rect) {\n      query['boundary.rect.min_lat'] = boundary.rect.minLat\n      query['boundary.rect.min_lon'] = boundary.rect.minLon\n      query['boundary.rect.max_lat'] = boundary.rect.maxLat\n      query['boundary.rect.max_lon'] = boundary.rect.maxLon\n    }\n  }\n\n  return run({ format, options, query, url })\n}\n\n/**\n * Reverse geocode using\n * Mapzen's {@link https://mapzen.com/documentation/search/reverse/|Reverse geocoding}\n * service.\n *\n * @param {Object} $0\n * @param {string} $0.apiKey                    The Mapzen API key\n * @param {boolean} $0.format\n * @param  {Object} $0.options                  options to pass to fetch (e.g., custom headers)\n * @param {{lat: number, lon: number}} $0.point Point to reverse geocode\n * @param {string} [$0.url='https://search.mapzen.com/v1/reverse']                     optional URL to override Mapzen reverse endpoint\n * @return {Promise}                            A Promise that'll get resolved with reverse geocode result\n */\nexport function reverse({\n  apiKey,\n  format,\n  options,\n  point,\n  url = reverseUrl\n}: Query): JSONArrayPromise {\n  const { lat, lon }: LonLatOutput = normalize(point)\n  return run({\n    format,\n    options,\n    query: {\n      api_key: apiKey,\n      point: {\n        lat,\n        lon\n      }\n    },\n    url\n  })\n}\n\n// TODO: turn this into one large async function?\n// TODO: replace Array<Object> with more specific output once tests work\nfunction run({\n  format = false,\n  options,\n  query,\n  url = searchUrl\n}: PeliasFetchArgs): JSONArrayPromise {\n  return fetch(`${url}?${stringify(query, { allowDots: true })}`, options)\n    .then((res) => res.json())\n    .then((json) => {\n      let jsonResponse = json\n      if (json && json.features && format) {\n        jsonResponse = json.features.map(split)\n      }\n\n      jsonResponse.isomorphicMapzenSearchQuery = query\n\n      return jsonResponse\n    })\n}\n\nfunction split({ geometry, properties }): Record<string, string | number> {\n  return Object.assign({}, properties, {\n    address: `${properties.label}${\n      properties.postalcode ? ' ' + properties.postalcode : ''\n    }`,\n    latlng: fromCoordinates(geometry.coordinates)\n  })\n}\n\nconst toExport = { autocomplete, reverse, search }\nexport default toExport\n"],"names":["fetch","require","mapzenUrl","autocompleteUrl","reverseUrl","searchUrl","autocomplete","apiKey","boundary","focusPoint","format","layers","options","sources","text","url","query","api_key","length","lat","lon","normalize","country","rect","minLat","minLon","maxLat","maxLon","run","search","size","Promise","resolve","reverse","point","stringify","allowDots","then","res","json","jsonResponse","features","map","split","isomorphicMapzenSearchQuery","geometry","properties","Object","assign","address","label","postalcode","latlng","fromCoordinates","coordinates","toExport"],"mappings":"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"}