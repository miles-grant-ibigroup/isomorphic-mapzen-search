{"version":3,"file":"isomorphic-mapzen-search.cjs.production.min.js","sources":["../index.ts"],"sourcesContent":["import { stringify } from 'qs'\nimport type { LonLatInput, LonLatOutput } from '@conveyal/lonlat'\nimport { normalize, fromCoordinates } from '@conveyal/lonlat'\n\nif (typeof fetch === 'undefined') {\n  require('isomorphic-fetch')\n}\n\nconst mapzenUrl = 'https://search.mapzen.com/v1'\nconst autocompleteUrl = `${mapzenUrl}/autocomplete`\nconst reverseUrl = `${mapzenUrl}/reverse`\nconst searchUrl = `${mapzenUrl}/search`\n\ntype Rect = {\n  maxLat: number\n  maxLon: number\n  minLat: number\n  minLon: number\n}\ntype Boundary = {\n  country: string\n  rect: Rect\n}\n\ntype Query = {\n  // apiKey is renamed depending on if it is being passed around or into fetch\n  // OK to disable this rule as api_key is a hack to conform with api\n  // eslint-disable-next-line camelcase\n  api_key: string\n  apiKey?: string\n  boundary?: Boundary\n  focusPoint?: LonLatInput\n  format?: boolean\n  layers?: string\n  options?: RequestInit // Built-in Typing\n  point?: GeoJSON.Point | LonLatOutput\n  size?: number\n  sources?: string\n  text?: string\n  url?: string\n}\n\ntype PeliasFetchArgs = {\n  format: boolean\n  options: RequestInit // Built-in Typing\n  query: Query\n  url: string\n}\n\ntype JSONArrayPromise = Promise<Array<JSON>>\n\n/**\n * Search for and address using\n * Mapzen's {@link https://mapzen.com/documentation/search/autocomplete/|Autocomplete}\n * service.\n *\n * @param {Object} $0\n * @param  {string} $0.apiKey                     The Mapzen API key\n * @param  {Object} $0.boundary\n * @param  {Object} $0.focusPoint\n * @param  {boolean} $0.format\n * @param  {string} $0.layers                     a comma-separated list of\n *   {@link https://mapzen.com/documentation/search/autocomplete/#layers|layer types}\n * @param  {Object} $0.options                    options to pass to fetch (e.g., custom headers)\n * @param  {string} [$0.sources='gn,oa,osm,wof']\n * @param  {string} $0.text                       query text\n * @param {string} [$0.url='https://search.mapzen.com/v1/autocomplete']                       optional URL to override Mapzen autocomplete endpoint\n * @return {Promise}                              A Promise that'll get resolved with the autocomplete result\n */\nexport function autocomplete({\n  apiKey,\n  boundary,\n  focusPoint,\n  format,\n  layers,\n  options,\n  sources = 'gn,oa,osm,wof',\n  text,\n  url = autocompleteUrl\n}: Query): JSONArrayPromise {\n  // build query\n  const query: Query = { api_key: apiKey, text }\n\n  if (sources && sources.length > 0) query.sources = sources\n\n  if (layers) {\n    query.layers = layers\n  }\n\n  if (focusPoint) {\n    const { lat, lon }: LonLatOutput = normalize(focusPoint)\n    query['focus.point.lat'] = lat\n    query['focus.point.lon'] = lon\n  }\n\n  if (boundary) {\n    if (boundary.country) query['boundary.country'] = boundary.country\n    if (boundary.rect) {\n      query['boundary.rect.min_lat'] = boundary.rect.minLat\n      query['boundary.rect.min_lon'] = boundary.rect.minLon\n      query['boundary.rect.max_lat'] = boundary.rect.maxLat\n      query['boundary.rect.max_lon'] = boundary.rect.maxLon\n    }\n  }\n\n  return run({\n    format,\n    options,\n    query,\n    url\n  })\n}\n\n/**\n * Search for an address using\n * Mapzen's {@link https://mapzen.com/documentation/search/search/|Search}\n * service.\n *\n * @param {Object} $0\n * @param {string} $0.apiKey                    The Mapzen API key\n * @param {Object} $0.boundary\n * @param {Object} $0.focusPoint\n * @param {boolean} $0.format\n * @param  {Object} $0.options                  options to pass to fetch (e.g., custom headers)\n * @param {number} [$0.size=10]\n * @param {string} [$0.sources='gn,oa,osm,wof']\n * @param {string} $0.text                      The address text to query for\n * @param {string} [$0.url='https://search.mapzen.com/v1/search']                     optional URL to override Mapzen search endpoint\n * @return {Promise}                            A Promise that'll get resolved with search result\n */\nexport function search({\n  apiKey,\n  boundary,\n  focusPoint,\n  format,\n  options,\n  size = 10,\n  sources = 'gn,oa,osm,wof',\n  text,\n  url = searchUrl\n}: Query): JSONArrayPromise {\n  if (!text) return Promise.resolve([])\n\n  const query: Query = {\n    api_key: apiKey,\n    size,\n    text\n  }\n\n  if (sources && sources.length > 0) query.sources = sources\n\n  if (focusPoint) {\n    const { lat, lon }: LonLatOutput = normalize(focusPoint)\n    query['focus.point.lat'] = lat\n    query['focus.point.lon'] = lon\n  }\n\n  if (boundary) {\n    if (boundary.country) query['boundary.country'] = boundary.country\n    if (boundary.rect) {\n      query['boundary.rect.min_lat'] = boundary.rect.minLat\n      query['boundary.rect.min_lon'] = boundary.rect.minLon\n      query['boundary.rect.max_lat'] = boundary.rect.maxLat\n      query['boundary.rect.max_lon'] = boundary.rect.maxLon\n    }\n  }\n\n  return run({ format, options, query, url })\n}\n\n/**\n * Reverse geocode using\n * Mapzen's {@link https://mapzen.com/documentation/search/reverse/|Reverse geocoding}\n * service.\n *\n * @param {Object} $0\n * @param {string} $0.apiKey                    The Mapzen API key\n * @param {boolean} $0.format\n * @param  {Object} $0.options                  options to pass to fetch (e.g., custom headers)\n * @param {{lat: number, lon: number}} $0.point Point to reverse geocode\n * @param {string} [$0.url='https://search.mapzen.com/v1/reverse']                     optional URL to override Mapzen reverse endpoint\n * @return {Promise}                            A Promise that'll get resolved with reverse geocode result\n */\nexport function reverse({\n  apiKey,\n  format,\n  options,\n  point,\n  url = reverseUrl\n}: Query): JSONArrayPromise {\n  const { lat, lon }: LonLatOutput = normalize(point)\n  return run({\n    format,\n    options,\n    query: {\n      api_key: apiKey,\n      point: {\n        lat,\n        lon\n      }\n    },\n    url\n  })\n}\n\n// TODO: turn this into one large async function?\n// TODO: replace Array<Object> with more specific output once tests work\nfunction run({\n  format = false,\n  options,\n  query,\n  url = searchUrl\n}: PeliasFetchArgs): JSONArrayPromise {\n  return fetch(`${url}?${stringify(query, { allowDots: true })}`, options)\n    .then((res) => res.json())\n    .then((json) => {\n      let jsonResponse = json\n      if (json && json.features && format) {\n        jsonResponse = json.features.map(split)\n      }\n\n      jsonResponse.isomorphicMapzenSearchQuery = query\n\n      return jsonResponse\n    })\n}\n\nfunction split({ geometry, properties }): Record<string, string | number> {\n  return Object.assign({}, properties, {\n    address: `${properties.label}${\n      properties.postalcode ? ' ' + properties.postalcode : ''\n    }`,\n    latlng: fromCoordinates(geometry.coordinates)\n  })\n}\n\nconst toExport = { autocomplete, reverse, search }\nexport default toExport\n"],"names":["fetch","require","searchUrl","autocomplete","apiKey","boundary","focusPoint","format","layers","options","sources","text","url","query","api_key","length","lat","lon","normalize","country","rect","minLat","minLon","maxLat","maxLon","run","search","size","Promise","resolve","reverse","point","stringify","allowDots","then","res","json","jsonResponse","features","map","split","isomorphicMapzenSearchQuery","geometry","properties","Object","assign","address","label","postalcode","latlng","fromCoordinates","coordinates","toExport"],"mappings":"+DAIqB,oBAAVA,OACTC,QAAQ,oBAGV,MAGMC,iDA0DUC,GAAaC,OAC3BA,EAD2BC,SAE3BA,EAF2BC,WAG3BA,EAH2BC,OAI3BA,EAJ2BC,OAK3BA,EAL2BC,QAM3BA,EAN2BC,QAO3BA,EAAU,gBAPiBC,KAQ3BA,EAR2BC,IAS3BA,sDAGMC,EAAe,CAAEC,QAASV,EAAQO,KAAAA,MAEpCD,GAAWA,EAAQK,OAAS,IAAGF,EAAMH,QAAUA,GAE/CF,IACFK,EAAML,OAASA,GAGbF,EAAY,OACRU,IAAEA,EAAFC,IAAOA,GAAsBC,YAAUZ,GAC7CO,EAAM,mBAAqBG,EAC3BH,EAAM,mBAAqBI,SAGzBZ,IACEA,EAASc,UAASN,EAAM,oBAAsBR,EAASc,SACvDd,EAASe,OACXP,EAAM,yBAA2BR,EAASe,KAAKC,OAC/CR,EAAM,yBAA2BR,EAASe,KAAKE,OAC/CT,EAAM,yBAA2BR,EAASe,KAAKG,OAC/CV,EAAM,yBAA2BR,EAASe,KAAKI,SAI5CC,EAAI,CACTlB,OAAAA,EACAE,QAAAA,EACAI,MAAAA,EACAD,IAAAA,aAqBYc,GAAOtB,OACrBA,EADqBC,SAErBA,EAFqBC,WAGrBA,EAHqBC,OAIrBA,EAJqBE,QAKrBA,EALqBkB,KAMrBA,EAAO,GANcjB,QAOrBA,EAAU,gBAPWC,KAQrBA,EARqBC,IASrBA,EAAMV,QAEDS,EAAM,OAAOiB,QAAQC,QAAQ,UAE5BhB,EAAe,CACnBC,QAASV,EACTuB,KAAAA,EACAhB,KAAAA,MAGED,GAAWA,EAAQK,OAAS,IAAGF,EAAMH,QAAUA,GAE/CJ,EAAY,OACRU,IAAEA,EAAFC,IAAOA,GAAsBC,YAAUZ,GAC7CO,EAAM,mBAAqBG,EAC3BH,EAAM,mBAAqBI,SAGzBZ,IACEA,EAASc,UAASN,EAAM,oBAAsBR,EAASc,SACvDd,EAASe,OACXP,EAAM,yBAA2BR,EAASe,KAAKC,OAC/CR,EAAM,yBAA2BR,EAASe,KAAKE,OAC/CT,EAAM,yBAA2BR,EAASe,KAAKG,OAC/CV,EAAM,yBAA2BR,EAASe,KAAKI,SAI5CC,EAAI,CAAElB,OAAAA,EAAQE,QAAAA,EAASI,MAAAA,EAAOD,IAAAA,aAgBvBkB,GAAQ1B,OACtBA,EADsBG,OAEtBA,EAFsBE,QAGtBA,EAHsBsB,MAItBA,EAJsBnB,IAKtBA,iDAEMI,IAAEA,EAAFC,IAAOA,GAAsBC,YAAUa,UACtCN,EAAI,CACTlB,OAAAA,EACAE,QAAAA,EACAI,MAAO,CACLC,QAASV,EACT2B,MAAO,CACLf,IAAAA,EACAC,IAAAA,IAGJL,IAAAA,IAMJ,SAASa,GAAIlB,OACXA,GAAS,EADEE,QAEXA,EAFWI,MAGXA,EAHWD,IAIXA,EAAMV,WAECF,SAASY,KAAOoB,YAAUnB,EAAO,CAAEoB,WAAW,MAAWxB,GAC7DyB,KAAMC,GAAQA,EAAIC,QAClBF,KAAME,QACDC,EAAeD,SACfA,GAAQA,EAAKE,UAAY/B,IAC3B8B,EAAeD,EAAKE,SAASC,IAAIC,IAGnCH,EAAaI,4BAA8B5B,EAEpCwB,IAIb,SAASG,GAAME,SAAEA,EAAFC,WAAYA,WAClBC,OAAOC,OAAO,GAAIF,EAAY,CACnCG,WAAYH,EAAWI,QACrBJ,EAAWK,WAAa,IAAML,EAAWK,WAAa,KAExDC,OAAQC,kBAAgBR,EAASS,eAIrC,MAAMC,EAAW,CAAEjD,aAAAA,EAAc2B,QAAAA,EAASJ,OAAAA"}